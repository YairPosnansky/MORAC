Start testing: Jan 29 18:33 Jerusalem Standard Time
----------------------------------------------------------
1/1 Testing: lexer_test
1/1 Test: lexer_test
Command: "C:/Users/posna/Desktop/DEV/YaronJava/MORAC/build/test_lexer.exe"
Directory: C:/Users/posna/Desktop/DEV/YaronJava/MORAC/build
"lexer_test" start time: Jan 29 18:33 Jerusalem Standard Time
Output:
----------------------------------------------------------

=== Testing Basic Declarations and Operations ===
Source code:
int main() {
    int x = 42;
    float y = 3.14;
    return x;
}


Lexical Analysis Output:
------------------------------------------------------------
TOKEN: INT              LEXEME: 'int            '  LINE: 1  COL: 1
TOKEN: IDENTIFIER       LEXEME: 'main           '  LINE: 1  COL: 2
TOKEN: LPAREN           LEXEME: '(              '  LINE: 1  COL: 2
TOKEN: RPAREN           LEXEME: ')              '  LINE: 1  COL: 2
TOKEN: LBRACE           LEXEME: '{              '  LINE: 1  COL: 3
TOKEN: INT              LEXEME: 'int            '  LINE: 2  COL: 5
TOKEN: IDENTIFIER       LEXEME: 'x              '  LINE: 2  COL: 6
TOKEN: ASSIGN           LEXEME: '=              '  LINE: 2  COL: 7
TOKEN: INTEGER          LEXEME: '42             '  LINE: 2  COL: 8
TOKEN: SEMICOLON        LEXEME: ';              '  LINE: 2  COL: 8
TOKEN: FLOAT            LEXEME: 'float          '  LINE: 3  COL: 5
TOKEN: IDENTIFIER       LEXEME: 'y              '  LINE: 3  COL: 6
TOKEN: ASSIGN           LEXEME: '=              '  LINE: 3  COL: 7
TOKEN: FLOAT_LIT        LEXEME: '3.14           '  LINE: 3  COL: 8
TOKEN: SEMICOLON        LEXEME: ';              '  LINE: 3  COL: 8
TOKEN: RETURN           LEXEME: 'return         '  LINE: 4  COL: 5
TOKEN: IDENTIFIER       LEXEME: 'x              '  LINE: 4  COL: 6
TOKEN: SEMICOLON        LEXEME: ';              '  LINE: 4  COL: 6
TOKEN: RBRACE           LEXEME: '}              '  LINE: 5  COL: 1
TOKEN: EOF              LEXEME: '               '  LINE: 6  COL: 1
------------------------------------------------------------


=== Testing Control Structures and Operators ===
Source code:
if (x <= 10) {
    while (y > 0) {
        y -= 1.5;
    }
}


Lexical Analysis Output:
------------------------------------------------------------
TOKEN: IF               LEXEME: 'if             '  LINE: 1  COL: 1
TOKEN: LPAREN           LEXEME: '(              '  LINE: 1  COL: 2
TOKEN: IDENTIFIER       LEXEME: 'x              '  LINE: 1  COL: 2
TOKEN: LESS_EQUAL       LEXEME: '<=             '  LINE: 1  COL: 3
TOKEN: INTEGER          LEXEME: '10             '  LINE: 1  COL: 4
TOKEN: RPAREN           LEXEME: ')              '  LINE: 1  COL: 4
TOKEN: LBRACE           LEXEME: '{              '  LINE: 1  COL: 5
TOKEN: WHILE            LEXEME: 'while          '  LINE: 2  COL: 5
TOKEN: LPAREN           LEXEME: '(              '  LINE: 2  COL: 6
TOKEN: IDENTIFIER       LEXEME: 'y              '  LINE: 2  COL: 6
TOKEN: GREATER          LEXEME: '>              '  LINE: 2  COL: 7
TOKEN: INTEGER          LEXEME: '0              '  LINE: 2  COL: 8
TOKEN: RPAREN           LEXEME: ')              '  LINE: 2  COL: 8
TOKEN: LBRACE           LEXEME: '{              '  LINE: 2  COL: 9
TOKEN: IDENTIFIER       LEXEME: 'y              '  LINE: 3  COL: 9
TOKEN: MINUS_ASSIGN     LEXEME: '-=             '  LINE: 3  COL: 10
TOKEN: FLOAT_LIT        LEXEME: '1.5            '  LINE: 3  COL: 11
TOKEN: SEMICOLON        LEXEME: ';              '  LINE: 3  COL: 11
TOKEN: RBRACE           LEXEME: '}              '  LINE: 4  COL: 5
TOKEN: RBRACE           LEXEME: '}              '  LINE: 5  COL: 1
TOKEN: EOF              LEXEME: '               '  LINE: 6  COL: 1
------------------------------------------------------------


=== Testing Comments and Strings ===
Source code:
/* Multi-line
   comment */
char *str = "Hello!";
// Single line comment
char c = 'X';


Lexical Analysis Output:
------------------------------------------------------------
TOKEN: CHAR             LEXEME: 'char           '  LINE: 2  COL: 1
TOKEN: MULTIPLY         LEXEME: '*              '  LINE: 2  COL: 2
TOKEN: IDENTIFIER       LEXEME: 'str            '  LINE: 2  COL: 2
TOKEN: ASSIGN           LEXEME: '=              '  LINE: 2  COL: 3
TOKEN: STRING_LIT       LEXEME: '"Hello!"       '  LINE: 2  COL: 4
TOKEN: SEMICOLON        LEXEME: ';              '  LINE: 2  COL: 4
TOKEN: CHAR             LEXEME: 'char           '  LINE: 3  COL: 1
TOKEN: IDENTIFIER       LEXEME: 'c              '  LINE: 3  COL: 2
TOKEN: ASSIGN           LEXEME:[line 3:4] Error: Unterminated string.
[line 2:6] Error: Invalid character.
 '=              '  LINE: 3  COL: 3
TOKEN: ERROR            LEXEME: ''X';
          '  LINE: 3  COL: 4
------------------------------------------------------------


=== Testing Complex Expressions ===
Source code:
int calculate(int a, float b) {
    return (a + b) * 2 - (3 / a);
}


Lexical Analysis Output:
------------------------------------------------------------
TOKEN: INT              LEXEME: 'int            '  LINE: 1  COL: 1
TOKEN: IDENTIFIER       LEXEME: 'calculate      '  LINE: 1  COL: 2
TOKEN: LPAREN           LEXEME: '(              '  LINE: 1  COL: 2
TOKEN: INT              LEXEME: 'int            '  LINE: 1  COL: 2
TOKEN: IDENTIFIER       LEXEME: 'a              '  LINE: 1  COL: 3
TOKEN: COMMA            LEXEME: ',              '  LINE: 1  COL: 3
TOKEN: FLOAT            LEXEME: 'float          '  LINE: 1  COL: 4
TOKEN: IDENTIFIER       LEXEME: 'b              '  LINE: 1  COL: 5
TOKEN: RPAREN           LEXEME: ')              '  LINE: 1  COL: 5
TOKEN: LBRACE           LEXEME: '{              '  LINE: 1  COL: 6
TOKEN: RETURN           LEXEME: 'return         '  LINE: 2  COL: 5
TOKEN: LPAREN           LEXEME: '(              '  LINE: 2  COL: 6
TOKEN: IDENTIFIER       LEXEME: 'a              '  LINE: 2  COL: 6
TOKEN: PLUS             LEXEME: '+              '  LINE: 2  COL: 7
TOKEN: IDENTIFIER       LEXEME: 'b              '  LINE: 2  COL: 8
TOKEN: RPAREN           LEXEME: ')              '  LINE: 2  COL: 8
TOKEN: MULTIPLY         LEXEME: '*              '  LINE: 2  COL: 9
TOKEN: INTEGER          LEXEME: '2              '  LINE: 2  COL: 10
TOKEN: MINUS            LEXEME: '-              '  LINE: 2  COL: 11
TOKEN: LPAREN           LEXEME: '(              '  LINE: 2  COL: 12
TOKEN: INTEGER          LEXEME: '3              '  LINE: 2  COL: 12
TOKEN: DIVIDE           LEXEME: '/              '  LINE: 2  COL: 13
TOKEN: IDENTIFIER       LEXEME: 'a              '  LINE: 2  COL: 14
TOKEN: RPAREN           LEXEME: ')              '  LINE: 2  COL: 14
TOKEN: SEMICOLON        LEXEME: ';              '  LINE: 2  COL: 14
TOKEN: RBRACE           LEXEME: '}              '  LINE: 3  COL: 1
TOKEN: EOF              LEXEME: '               '  LINE: 4  COL: 1
------------------------------------------------------------


=== Testing Error Cases ===
Source code:
int test() {
    int @invalid = 42;
    char *str = "unterminated;
    return 0;
}


Lexical Analysis Output:
------------------------------------------------------------
TOKEN: INT              LEXEME: 'int            '  LINE: 1  COL: 1
TOKEN: IDENTIFIER       LEXEME: 'test           '  LINE: 1  COL: 2
TOKEN: LPAREN           LEXEME: '(              '  LINE: 1  COL: 2
TOKEN: RPAREN           LEXEME: ')              '  LINE: 1  COL: 2
TOKEN: LBRACE           LEXEME: '{              '  LINE: 1  COL: 3
TOKEN: INT              LEXEME: 'int            '  LINE: 2  COL: 5
TOKEN: ERROR            LEXEME: '@              '  LINE: 2  COL: 6
------------------------------------------------------------

<end of output>
Test time =   0.01 sec
----------------------------------------------------------
Test Passed.
"lexer_test" end time: Jan 29 18:33 Jerusalem Standard Time
"lexer_test" time elapsed: 00:00:00
----------------------------------------------------------

End testing: Jan 29 18:33 Jerusalem Standard Time
